README
================

``` r
knitr::opts_chunk$set(echo = F)
library(BehaviouR)
#library(data.table)
library(ggplot2)
library(patchwork)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) 
knitr::opts_chunk$set(echo=T,   fig.path = "README_figs/README-")
```

# BehaviouR

The task in the video is based on the *Novel-Object Recognition Task*.
Therefore, we have two objects in the arena which are explored by the
mouse. The data generated by DeepLabCut can be returned as csv file and
includes labels, coordinates but also the likelihood for any given label
at any given point in time. The sampling rate of the video in this
example is a 1/3 of 25 Hz which makes it a frame rate of 8.33 Hz. The
reason for the 1/3 term is the recording format *.avi* where every third
frame is saved and the rest skipped and interpolated later.

``` r
FileName <- paste0("RawData/20180903_Schmitz_PaS_B1_C1_NL_",
                   "Day1_NOVEL_DSC001663DLC_resnet50_NOVEL_",
                   "VIDEONov7shuffle1_100000.csv")
FrameRate <- 25/3
ObjectNumber <- 2
```

## Load Data

The data can be loaded using the `BehaviouR` package with its function
`DeepLabCutLoad()`. The function requires some information about the
labels one is interested in, namely body parts and objects. In this case
we define two groups of the mouse (head and body). These two groups are
then subdivided into different parts/labels which are forming the
structure. The labels have to refer to column names which appear in the
DeepLabCout output. In the following example *ear*, *nose* and *ear*,
*tail*. When the term *“ear”* is used the function will search for any
label which contains the term. Therefore, *leftear* and *rightear* are
both included. However, this requires explicit labels in cases where
only one of the two is required. The scaling arguments can be used to
adjust for the unit size per pixel.

``` r
library(BehaviouR)
MouseBodyList <- list()
MouseBodyList$head <- c("ear", "nose")
MouseBodyList$body <- c("ear", "tail")
ObjectList <- list("object")

MouseDataTable <- DeepLabCutLoad(FileName = FileName,
                                 FrameRate = FrameRate,
                                 MouseLabels = MouseBodyList,
                                 ObjectLabels = ObjectList,
                                 ObjectNumber = ObjectNumber,
                                 xScale = 1,
                                 yScale = 1)
summary(MouseDataTable)
```

    ##             Length Class      Mode
    ## DataTable   14     data.table list
    ## ObjectTable  3     data.table list

## Calculate Egocentric Parameters

The output of `MouseDataTable` will be a list consisting of two
`data.table`s. The first one includes the egocentric coordinates of the
mouse which are extracted from the labels provided in the
`MouseBodyList` and the second one will give the table for stationary
objects from the `ObjectList`. If an object is in the list of stationary
objects coordinates will be adjusted and fixed. If the interest is in
objects which move, and this is something which should be kept as
information, it is recommended to put the labels in the `MouseBodyList`
and assign them with for example `MouseBodyList$object` or another clear
description. The input argument for `DeepLabCutLoad` should be including
`ObjectNumber = 0`. The argument `ObjectLabels` will then be ignored.

The package offers some basic functions which allow you to calculate
**speed**, **distance**, **length** or **angle** etc. for different
structures. In this example functions can be applied to the coordinate
table.

``` r
DistSpeedCalc(CoordTable = MouseDataTable$DataTable,
              SpeedRef = "bodyCentroid",
              Interval = 1/FrameRate)
AddCentroid(CoordTable = MouseDataTable$DataTable,
            CornerNames = list("ear"),
            ReferenceColumn = "frame",
            OutputName = "BetweenEars")
VectorLength(CoordTable = MouseDataTable$DataTable,
             VectorStart = "tailbase",
             VectorEnd = "BetweenEars",
             OutputName = "BodyLength")
AngleCalc(CoordTable = MouseDataTable$DataTable,
          VectorStart = "BetweenEars",
          VectorEnd = "nose",
          OutputName = "HeadAngle")
AngleCalc(CoordTable = MouseDataTable$DataTable,
          VectorStart = "tailbase",
          VectorEnd = "BetweenEars",
          OutputName = "BodyAngle")
AngleDiff(CoordTable = MouseDataTable$DataTable,
          Angle1 = "BodyAngle",
          Angle2 = "HeadAngle",
          OutputName = "ViewAngle")
```

## Calculate Stationary Object Parameters

The object specific calculations can be performed in the same way.
`ObjectDistance()` will calculate the distances from a reference point
to **all** the objects in the `ObjectTable`. The calculation for the
approaching angle is performed in a similar manner using
`ObjectAngle()`. The `AddCentroid()` function allows to compute the
centroid of a multi-label structure. This helps to evaluate a position
of an object or can reduce noise.

``` r
ObjectDistance(CoordTable = MouseDataTable$DataTable,
               ObjectTable = MouseDataTable$ObjectTable,
               ObjectLabels = ObjectList,
               Ref = "headCentroid")
ObjectAngle(CoordTable = MouseDataTable$DataTable,
            ObjectTable = MouseDataTable$ObjectTable,
            ObjectLabels = ObjectList,
            Ref = "headCentroid")
VectorLength(CoordTable = MouseDataTable$DataTable,
             VectorStart = "nose",
             VectorEnd = "BetweenEars",
             OutputName = "headLength")
AddCentroid(CoordTable = MouseDataTable$DataTable,
            CornerNames = list("ear"),
            ReferenceColumn = "frame",
            OutputName = "BetweenEars")
```

## Plotting Data

The data can be plotted using functions and strings as references. For
some functions 2D and 1D options are available, meaning if `x` and `y`
are valid references a 2D-plot is generated showing the trajectory and
the target parameter in colour code. The `LocationPlot()` further has
the option to output the density/probability of occupancy. The other
possible functions are `SpeedPlot()`, `AnglePlot()`, `DistancePlot()`,
and `LengthPlot()` with their 1D and 2D functionality. Currently, the
plots are implemented with colour blind friendly colour schemes.

``` r
# Plot functions
SpeedPlot <- SpeedPlot(DataTable = MouseDataTable$DataTable,
                       Speed = "SpeedbodyCentroid",
                       x = "headCentroid_x",
                       y = "headCentroid_y",
                       ObjectTable = MouseDataTable$ObjectTable)

DensityPlot <- LocationPlot(DataTable = MouseDataTable$DataTable,
                         x = "headCentroid_x",
                         y = "headCentroid_y",
                         ObjectTable = MouseDataTable$ObjectTable,
                         Density = T)


if(ObjectNumber>0) {
  ObjectAnglePlots <- lapply(X = 1:ObjectNumber, FUN = function(objID) {
    AnglePlot(DataTable = MouseDataTable$DataTable,
              Angle = paste0("object_",objID,"_headCentroid_Angle"),
              x = "headCentroid_x",
              y = "headCentroid_y",
              ObjectTable = MouseDataTable$ObjectTable,
              colourScheme = "dark")
  })   
}


SpeedPlotLine <- SpeedPlot(DataTable = MouseDataTable$DataTable,
                           Speed = "SpeedbodyCentroid")

DistancePlotLine <- DistancePlot(DataTable = MouseDataTable$DataTable,
                                 Distance = "CumDistbodyCentroid")

ObjectDistancePlotLine <- DistancePlot(DataTable = MouseDataTable$DataTable,
                                       Distance = "headCentroid_Distance",
                                       ObjectTable = MouseDataTable$ObjectTable,
                                       ObjectDistance = T)

RearingPlotLine <- LengthPlot(DataTable = MouseDataTable$DataTable,
                              Length = "BodyLength")

RearingPlot <- LengthPlot(DataTable = MouseDataTable$DataTable,
                          Length = "BodyLength",
                          x = "headCentroid_x",
                          y = "headCentroid_y",
                          ObjectTable = MouseDataTable$ObjectTable)
```

The plots can be arranged and panels generated by using the `patchwork`
library.

``` r
# Arrange Plots
if(ObjectNumber>0) {
  MovementPlot <- (SpeedPlot | ObjectAnglePlots[[1]] | ObjectAnglePlots[[2]]) / ObjectDistancePlotLine + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(size=24))
  ggsave(plot = MovementPlot, filename = "Plots/MovementPlot.pdf", device = "pdf", width = 10.4, height = 6)
}

OutPutPlotRearing <- RearingPlotLine + RearingPlot + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(size=24)) 
OutPutPlotMap <- SpeedPlot + DensityPlot + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(size=24)) 
OutPutPlotMovement <- SpeedPlotLine + DistancePlotLine + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(size=24)) 

ggsave(plot = OutPutPlotMap, filename = "Plots/OutPutPlotMap.pdf", device = "pdf", width = 10.4, height = 4)
ggsave(plot = OutPutPlotMovement, filename = "Plots/OutPutPlotMovement.pdf", device = "pdf", width = 10.4, height = 4)
ggsave(plot = ObjectDistancePlotLine, filename = "Plots/ObjectDistancePlotLine.pdf", device = "pdf", width = 5, height = 3)
ggsave(plot = OutPutPlotRearing, filename = "Plots/RearingPlot.pdf", device = "pdf", width = 5, height = 3)
```

The plot for speed (2D) and occupancy (2D):
<img src="README_figs/README-OutPutPlotMap-1.png" width="280" height="120" />
The plot for speed (1D) and Distance (1D):
<img src="README_figs/README-OutPutPlotMovement-1.png" width="240" height="120" />
The plot for stationary object distances:
<img src="README_figs/README-ObjectDistancePlotLine-1.png" width="240" height="120" />
The plots for speed, object approach angle for both objects, and the
distance to the objects over time:
<img src="README_figs/README-MovementPlot-1.png" width="400" height="200" />

The last plot shows the rearing measured as the length of the body. If
the animal is walking normally the vector length will be long. If the
animal rears, meaning it will get up, the vector will be shorter.
<img src="README_figs/README-OutPutPlotRearing-1.png" width="240" height="120" />

Any further adjustments or changes to the plot can be appended. For
example when a different label is required one can add the `ggplot2`
functions to the generated plot. In the following case we want to change
the *“Length (px)”* to a more general *“Rearing”*. Further we will
remove the numbers (*label*) next to the colour bar. Since it is a
arbitrary measure absolute numbers might not be required.

``` r
RearingPlot+
  scale_color_viridis_c(guide = guide_colourbar(title = "Rearing", label = FALSE), direction = -1)
```

    ## Scale for 'colour' is already present. Adding another scale for 'colour',
    ## which will replace the existing scale.

<img src="README_figs/README-ChangeAxis-1.png" width="140" height="120" />

``` r
ggsave(plot = OutPutPlotRearing, filename = "Plots/RearingPlotColourbar.pdf", device = "pdf", width = 5, height = 3)
```

The combination of functions and plotting features will allow for easier
analysis of the `DeepLabCut` output and make data more approachable.
Future features will include measures to quantify behaviour and
adjustments to object plotting and analysis allowing for more
flexibility.
