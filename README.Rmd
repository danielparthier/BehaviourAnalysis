---
title: "Analysis Overview"
author: "Daniel Parthier"
date: "20.11.2019"
output: 
  html_document:
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
library(data.table)
library(readr)
library(ggplot2)
library(viridis)
library(patchwork)
knitr::opts_knit$set(root.dir = getwd()) 
knitr::opts_chunk$set(echo=T,   fig.path = "README_figs/README-")
```

## Analysis Brainstorming
The data generated by DeepLabCut will be always in this csv format, however, it can change in terms of labels or how many columns will be generated (Label number). We for now will work with a 1/3 of 25 Hz which makes it a frame rate of 8.33. I implemented a function which takes the number of objects and later seperates the coordinates without knowing where they were. This is implemented with k-means clustering. My hope is that it will be flexible for different (immobile) objects independently of the count. 

```{r MetaData}
# Information about recording
FileName <- "RawData/20180903_Schmitz_PaS_B1_C1_NL_Day1_NOVEL_DSC001663DLC_resnet50_NOVEL_VIDEONov7shuffle1_100000.csv"
FrameRate <- 25/3
ObjectNumber <- 2
```

To analyse the data we will all have to start with the CSV. This is fairly easy to load but the naming convention requires some adjustments.

```{r}
RawDT <- fread(file = FileName, skip = 0)
RawDT[1:3,1:3]
```
As we can see the first two rows have labels. Therefore we have to clean and seperate them and later stitch them back together as unique column names.

```{r LoadData}
# Load data
DataSet <- fread(file = FileName, skip = 2)
LabelNames <- fread(file = FileName, nrows = 1)

# Construct unique columns
ColumnNames <- paste(LabelNames, colnames(DataSet), sep="_")
colnames(DataSet) <- ColumnNames

# Correct for inverse y coordinates
DataSet[, (grep("_y", colnames(DataSet))) := 
          (lapply(.SD, function(x){-x})), 
        .SDcols = grep("_y", colnames(DataSet))]

# Generate mouse table with bodyparts
MouseData <- DataSet[,.SD,
                     .SDcols = !(names(DataSet) %like% "likelihood") & (names(DataSet) %like% "nose|ear|tail|body")]

# Print table
MouseData[1:3,1:3]
```

Having a "clean" data set allows us now to calculate properties of the movement or the position. Here we will quickly look at the Distance (length of the vector at any given point) and the speed (vector length as function of time). To get good estimates for the speed we will use the centroid of the body, however, for the location we will use the centroid of the head since it is the part which is used for exploration and contact.


```{r CalculateLocation}
# Calculate centroid
MouseData[,centroid_x:=sum(.SD)/3,
          .SDcols = !(names(MouseData) %like% "nose") & (names(MouseData) %like% "_x"),
          by = bodyparts_coords][
            ,centroid_y:=sum(.SD)/3,
            .SDcols = !(names(MouseData) %like% "nose") & (names(MouseData) %like% "_y"),
            by = bodyparts_coords]

MouseData[,head_x:=sum(.SD)/2,
              .SDcols = (names(MouseData) %like% "ear") & (names(MouseData) %like% "_x"),
              by = bodyparts_coords][
                ,head_y:=sum(.SD)/2,
                .SDcols = (names(MouseData) %like% "ear") & (names(MouseData) %like% "_y"),
                by = bodyparts_coords]
```

With the combination of the two we can not only get the speed but also the head direction of the animal.

```{r DistSpeedCalc}
# Angle
MouseData[,head_angle:=(atan2(x = (nose_x-head_x),y = (nose_y-head_y))),][
  ,body_angle:=(atan2(x = (head_x-tailbase_x),y = (head_y-tailbase_y))),][
    ,view_angle:=head_angle-body_angle,] 

# Calculate Speed/Distance travelled
MouseData[,InstDistance := sqrt((shift(centroid_x, type = "lead") - centroid_x)^2+abs(shift(centroid_y, type = "lead") - centroid_y)^2)][
  ,Speed := InstDistance/(1/FrameRate)][
    ,CumDist := cumsum(InstDistance)]
```

The syntax I use is with the `data.table` approach which is rather **SQL** like than **R** or **Python**. It is just super fast and keeps a clean table. Absolutely personal preference and I am willing to learn! The object coordinates can now be used to seperate **n** numbers of objects using k-means. This will assign cluster numbers to based on location. What this means in the end is that jumping labels will be corrected. Here I will use the median XY for any given object in order to estimate the exact location without jitter. Then we will create a new table which just holds the coordinates for the objects.

```{r ObjectLocation, warning=F}
# Find Object location
ObjectSet <- data.table(x=data.table::melt(DataSet[,.SD,
                                                   .SDcols = !(names(DataSet) %like% "likelihood") & (names(DataSet) %like% "object") & (names(DataSet) %like% "x")])$value,
                        y = data.table::melt(DataSet[,.SD,
                                                     .SDcols = !(names(DataSet) %like% "likelihood") & (names(DataSet) %like% "object") & (names(DataSet) %like% "y")])$value)
ObjectSet$ObjectLoc <- kmeans(x = ObjectSet[,.(x,y)], centers = ObjectNumber)$cluster
ObjectCoord <- ObjectSet[,.(x=median(x),y=median(y)), by=ObjectLoc]

# Print table
ObjectCoord
```
The location is calculated by vector length of mouse (nose) to the object. This should be further optimised using the centroid of the mouse. I guess it will be more stable too.
```{r DistanceCaculation}
# Calculate angle difference from object to mouse view
if(ObjectNumber>0) {
  for(i in 1:ObjectNumber) {
    object_angle <- paste("object", i, "angle", sep = "_")
    object_head_angle <- paste("object", i, "head_angle", sep = "_")
    MouseData[,eval(object_angle):=(atan2(x = (ObjectCoord[ObjectLoc==i, x]-head_x),
                                          y = (ObjectCoord[ObjectLoc==i, y]-head_y))),][
                                            ,eval(object_head_angle):=get(object_angle)-head_angle,][
                                              get(object_head_angle) > pi, eval(object_head_angle):=get(object_head_angle)-2*pi,][
                                                get(object_head_angle) < -pi, eval(object_head_angle):=get(object_head_angle)+2*pi,]
    
    # Calculate object distance
    MouseData[,paste0("DistToObject",i):=sqrt((nose_x-ObjectCoord[ObjectLoc==i, x])^2+(nose_y-ObjectCoord[ObjectLoc==i, y])^2)]
  }
}  
```

To tidy up the table and to make it easier to plot with `ggplot2` I will restructure the table to "long format". I could also use for this pupose the `reshape` function. However, here I will do it quickly manually to assign directly the right labels.

```{r DistanceTable, warning=F}
if(ObjectNumber>0) {
  # Generate distance table
  ObjectDistance <- data.table::melt.data.table(MouseData[,.SD,.SDcols = (names(MouseData) %like% "DistToObject")])
  ObjectDistance[,ObjectNr := gsub("DistToObject", "", variable)][,Time := rep(MouseData$bodyparts_coords/FrameRate, times = ObjectNumber)][,variable:=NULL]
  setnames(x = ObjectDistance, old = "value", new = "Distance")
}
```

We can then generate plots showing our computed parameters. Here we should check though which parameters are of importance and how to present them.    Furthermore, we will have to check for the object size and validate the pixel size to get later proper measurements.

```{r GeneratePlots, echo=F, message=F, warning=F}
# Generate Plots
SpeedPlot <- ggplot(data = MouseData, aes(x = head_x, y = head_y, colour = Speed))+
  geom_path()+
  scale_color_viridis()+
  labs(colour = "Speed\n(px/s)")+
  geom_point(data = ObjectCoord, aes(x = x, y = y), shape = 21, colour = "black", alpha = 0.5, size = 8, stroke = 2)+
  annotate("text", x = ObjectCoord$x, y = ObjectCoord$y, label = ObjectCoord$ObjectLoc)+
  theme_void()+
  theme(legend.title.align=0.5)

DensityPlot <- ggplot(data = MouseData, aes(x = head_x, y = head_y))+
  stat_density_2d(geom = "raster", aes(fill = stat(density)), contour = FALSE, n = c(500,500))+
  scale_fill_viridis()+
  labs(fill = "Density")+
  geom_point(data = ObjectCoord, aes(x = x, y = y), shape = 21, colour = "black", alpha = 0.5, size = 8, stroke = 2)+
  annotate("text", x = ObjectCoord$x, y = ObjectCoord$y, label = ObjectCoord$ObjectLoc)+
  theme_void()+
  theme(legend.title.align=0.5)

# Plot angle to object given that there is an object
if(ObjectNumber>0) {
  ObjectAnglePlots <- lapply(X = 1:ObjectNumber, FUN = function(x){
    PlotName <- paste0("AnglePlotObject", x)
    AnglePlot <- ggplot(data = MouseData, aes(x = head_x, y = head_y, colour = get(paste0("object_",x,"_head_angle")) *180/pi))+
      geom_path(size=1, linejoin = "round", lineend = "round")+
      scale_color_gradientn(colours = rainbow(5), limits = c(-180,180), breaks = c(-180, -90, 0, 90, 180))+
      guides(colour = guide_colourbar(ticks = FALSE, label.position = "right", title.position = "top"))+
      labs(colour = "Angle\n(Degree)")+
      geom_point(data = ObjectCoord, aes(x = x, y = y), shape = 21, colour = "black", alpha = 0.5, size = 8, stroke = 2)+
      annotate("text", x = ObjectCoord$x, y = ObjectCoord$y, label = ObjectCoord$ObjectLoc)+
      theme_void()+
      theme(legend.title.align=0.5)
    assign(x = PlotName, value = AnglePlot)
    return(get(PlotName))
  })
  AnglePlot <- wrap_plots(ObjectAnglePlots)
}

SpeedPlotLine <- ggplot(data = MouseData, aes(x = bodyparts_coords/FrameRate, y = Speed))+
  geom_line()+
  scale_x_continuous(expand = c(0,0))+
  scale_y_continuous(expand = c(0,0))+
  ylab("Speed (px/s)")+
  xlab("Time (s)")+
  theme_classic()+
  theme(legend.title.align=0.5)

DistancePlotLine <- ggplot(data = MouseData, aes(x = bodyparts_coords/FrameRate, y = CumDist))+
  geom_line()+
  scale_x_continuous(expand = c(0,0))+
  scale_y_continuous(expand = c(0,0))+
  ylab("Distance Travelled (px)")+
  xlab("Time (s)")+
  theme_classic()+
  theme(legend.title.align=0.5)

ObjectDistancePlotLine <- ggplot(data = ObjectDistance, aes(x = Time, y = Distance, group = ObjectNr, colour = ObjectNr))+
  geom_line()+
  scale_x_continuous(expand = c(0,0))+
  scale_y_continuous(expand = c(0,0))+
  scale_color_viridis(discrete=TRUE)+
  labs(colour = "Object")+
  ylab("Distance to Object (px)")+
  xlab("Time (s)")+
  theme_classic()+
  theme(legend.title.align=0.5)

MovementPlot <- (SpeedPlot | ObjectAnglePlots[[1]] | ObjectAnglePlots[[2]]) / ObjectDistancePlotLine + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(size=24))
OutPutPlotMap <- SpeedPlot + DensityPlot + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(size=24)) 
OutPutPlotMovement <- SpeedPlotLine + DistancePlotLine + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(size=24))
```

The first plot (A) shows the trajectory of the animal and in colour code the speed at the given segment. This might indicate where the animal is standing still and where it is just running from A to B. We will take a look at B the density of the location. This shows the likelihood of the animal being at any given point on the map. Yellow will indicate a high probability of the animal visiting the spot. Blue is very low or not even visited once. I also added the objects as circles. The size of course is not correct and would need to be changed according to the real object (I guess but it is not the highest priority). 

```{r DensityPlot, echo=F, warning=F, dpi=250}
OutPutPlotMap
```

The speed plot (A) is showing the change of speed over time. It looks like it might not change much but more analysis could indicate a trend that they are just moving less in the end due to boredom or exhaustion. Similarly to the speed the distance (B) over time as cumulative distance could also be a measure of exploration. A linear relationship would mean equal exploration whereas a flattend curve would mean less exploration in the end.

```{r, echo=F, warning=F, dpi=250}
OutPutPlotMovement
```

The object distance plot (C) shows the distance to object 1 and 2 at any given point in time. This plot would show a continous preference or equally distributed exploration. Further we can explore the angle with which the animal is looking at the objects (B and C) for each object.

```{r, echo=F, warning=F, dpi=250}
MovementPlot
```
